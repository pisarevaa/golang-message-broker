# golang-message-broker

Брокер сообщений на Golang

# Шаги по запуску сервиса
1. Скопируйте и измените переменные окружения:
```
cp .env.example .env
```
2. Запустите API сервер
```
make run_api
```

# Swagger документация

[http://localhost:7000/swagger/index.html](http://localhost:7000/swagger/index.html)


# Для разработчиков
Запус линтеров
```
make lint
```
Запуск тестов
```
make test
```
Генерация swagger документации
```
make swag_format && make swag_generate
```
Генерация моков для тестов
```
make mock_generate
```

# Ссылка на задание
https://balun-team.yonote.ru/share/87f296a0-48fa-44e0-b8ca-d0eea9d67a71/doc/samostoyatelnaya-rabota-vt5nM6MfRE

# Описание сервиса

Брокер сообщений будет представлять собой приложение, внутри которого будет множество очередей. Очереди создаются при старте приложения через конфигурационный файл, переменные окружения или аргументы командной строки (*во время исполнения приложения нельзя добавлять и удалять очереди*). Каждая очередь должна быть фиксированного размера, а также с ней должно ассоциироваться уникальное название, при помощи которого можно будет взаимодействовать с очередью (*размер очереди и ключ также конфигуриуется при старте приложения*). Сообщения в очередях будут храниться в оперативной памяти - **ничего на диск записывать не нужно**. Сообщения могут представлять собой абсолютно любые данные, сериализованые в формате JSON.

__У брокера сообщений будет крайне простой API__ - можно отправить сообщение в конкретную очередь, либо создать подписку на конкретную очередь.

```go
POST ${address}/v1/queues/${queue_name}/messages
POST ${address}/v1/queues/${queue_name}/subscriptions
```

При отправке сообщения в очередь, сообщение должно быть доставлено всем подписчикам этой очереди. Сообщение удаляется после того, как оно будет доставлено всем подписчикам. Если подписчиков нет, то сообщения хранятся в очереди до тех пор, пока не появятся подписчики. Если очередь переполнена, то брокер сообщений должен вернуть ошибку клиенту при отправке сообщения. Подписчиков у очереди должно быть ограниченное количество (*ограничение конфигурируется при старте*).


> Например, если на очередь `app_events` подписано три подписчика, то при отправке сообщения `{“event”:”delivered”}` в эту очередь - три подписчика должны будут получить это сообщение. Если есть еще другие подписчики, который подписаны на другие очереди, то они не должны получать сообщений из очереди `app_events`